!=========     weno addin     ================
!==     by Mach Shern ,Jun 22,2011     =======
!==  data generated by Matlab, see weno.m  ===
!=============================================

!================================================
 subroutine weno2d_init(weno_k)
!================================================ 
 use imsl
 use main

 implicit none
   integer :: weno_k
   integer :: ap(weno_k+1),weno2
   integer :: kp,jp,ipi,cop,odp
   real(8) :: kxil,kxir
   real(8) :: kxlb(2*weno_k-1),kxrb(2*weno_k-1),&
  &           kxlg(2*weno_k-1),kxrg(2*weno_k-1),&
!
  &           ctlb(weno_k,weno_k),ctrb(weno_k,weno_k),&
  &           ctlg(weno_k,weno_k),ctrg(weno_k,weno_k)

   real(8) :: Pint(weno_k,weno_k)
   real(8) :: Btmp(2*weno_k-1,weno_k),iBtmp(weno_k,weno_k)
   real(8) :: rhd(weno_k,1)

 ap(weno_k+1)=0.d0
 ap(1:weno_k)=1.d0
 weno2=2*weno_k-1


 Pint(1:weno_max,1:weno_max)=0.d0
!==  linear best weights  : dr ========
 do  kp=1,weno_k-1

    do  jp=1,weno_k
       ap(jp)=(jp-kp)*ap(jp)	
    enddo

	do  jp= kp+1,weno_k
	   
       do ipi= kp+1,weno_k
        cop=ap(jp)*ap(ipi)
		odp=dble(ipi+jp-1-2*kp)
        Pint(ipi,jp)=Pint(ipi,jp)+dble(cop)*(0.5d0**odp-(-0.5d0)**odp)/odp
	   enddo

	enddo

 enddo

!= solve linear system ===================

   do ipi=1,weno2
   	   kxlb(ipi)=(-0.5d0)**(ipi-1)
	   kxrb(ipi)=( 0.5d0)**(ipi-1)
	   kxlg(ipi)=(-sqrt(3.d0)/6.d0)**(ipi-1)
	   kxrg(ipi)=( sqrt(3.d0)/6.d0)**(ipi-1)
   end do


 do kp=1,weno_k

   do jp= 1,weno_k

     kxil=jp+kp-weno_k-1.5d0
     kxir=kxil+1.0d0

     do ipi=1,weno2
	   Btmp(ipi,jp)=(kxir**ipi-kxil**ipi)/ipi

	 enddo 

   enddo



   iBtmp=.i.Btmp(1:weno_k,1:weno_k)
   Binv(1:weno_k,1:weno_k,kp)=(iBtmp.x.Pint).x.(.t.iBtmp)

   crb(1,1:weno_k,kp)=iBtmp.x.kxlb(1:weno_k)
   crb(2,1:weno_k,kp)=iBtmp.x.kxrb(1:weno_k)
   crg(1,1:weno_k,kp)=iBtmp.x.kxlg(1:weno_k)
   crg(2,1:weno_k,kp)=iBtmp.x.kxrg(1:weno_k)

   ctlb(1:weno_k,kp)=Btmp(weno_k:weno2,1:weno_k).x.crb(1,1:weno_k,kp)
   ctrb(1:weno_k,kp)=Btmp(weno_k:weno2,1:weno_k).x.crb(2,1:weno_k,kp)
   ctlg(1:weno_k,kp)=Btmp(weno_k:weno2,1:weno_k).x.crg(1,1:weno_k,kp)
   ctrg(1:weno_k,kp)=Btmp(weno_k:weno2,1:weno_k).x.crg(2,1:weno_k,kp)

    
 end do
   
   drb(1,1:weno_k)=ctlb.ix.kxlb(weno_k:weno2)
   drb(2,1:weno_k)=ctrb.ix.kxrb(weno_k:weno2)
   drg(1,1:weno_k)=ctlg.ix.kxlg(weno_k:weno2)
   drg(2,1:weno_k)=ctrg.ix.kxrg(weno_k:weno2)
end subroutine weno2d_init


!======================================================================
subroutine weno2d_main(weno_k)
!======================================================================
  use imsl
  use main
  
  implicit none
  integer :: weno_k
  integer :: i,j,ig,wk
  real(8) :: stcro(weno_k),stcvx(weno_k),stcvy(weno_k),stcp(weno_k),&
&            annro,annvx,annvy,annp,&
&            crtmp(weno_k),drtmp,ar
  real(8) :: sumr(2),sumu(2),sumv(2),sump(2)!,&
!&            sumrr,sumur,sumvr,sumpr
  real(8) :: Btmp(weno_k,weno_k)

  call weno2d_bc

  do i=ib-weno_k+1,im+weno_k-2
    
	 do j= jb,jm-1

       sumr(1:2)=0.d0
	   sumu(1:2)=0.d0
	   sumv(1:2)=0.d0
	   sump(1:2)=0.d0

!	   sumrr=0.d0
!	   sumur=0.d0
!	   sumvr=0.d0
!       sumpr=0.d0

	   rownj(1:2,i,j)=0.d0
	   vxwnj(1:2,i,j)=0.d0
	   vywnj(1:2,i,j)=0.d0
	    pwnj(1:2,i,j)=0.d0

!	   rownn(i,j)=0.d0
!	   vxwnn(i,j)=0.d0
!	   vywnn(i,j)=0.d0
!	    pwnn(i,j)=0.d0

! loop on different stencil

	   do wk=1,weno_od
          Btmp=Binv(1:weno_od,1:weno_od,wk)  !ÓÃÀ´Çóbeta

          stcro=ro(i,j-weno_od+wk:j+wk-1)
          stcvx=vx(i,j-weno_od+wk:j+wk-1)
          stcvy=vy(i,j-weno_od+wk:j+wk-1)
           stcp= p(i,j-weno_od+wk:j+wk-1)

          annro=dot_product(stcro,matmul(Btmp,stcro))+1.d-6
          annvx=dot_product(stcvx,matmul(Btmp,stcvx))+1.d-6
          annvy=dot_product(stcvy,matmul(Btmp,stcvy))+1.d-6
           annp=dot_product( stcp,matmul(Btmp, stcp))+1.d-6
          
          do ig=1,2
                 
           crtmp=crg(ig,1:weno_k,wk)
           drtmp=drg(ig,wk)
! ro
           ar=drtmp/annro/annro
           rownj(ig,i,j)=rownj(ig,i,j)+ar*dot_product(stcro,crtmp)
           sumr(ig)=sumr(ig)+ar
! vx                 
           ar=drtmp/annvx/annvx
           vxwnj(ig,i,j)=vxwnj(ig,i,j)+ar*dot_product(stcvx,crtmp)
           sumu(ig)=sumu(ig)+ar
! vy                 
           ar=drtmp/annvy/annvy
           vywnj(ig,i,j)=vywnj(ig,i,j)+ar*dot_product(stcvy,crtmp)
           sumv(ig)=sumv(ig)+ar
!  p                 
           ar=drtmp/annp/annp
           pwnj(ig,i,j)= pwnj(ig,i,j)+ar*dot_product( stcp,crtmp)
           sump(ig)=sump(ig)+ar

          enddo
	   enddo

	   rownj(1:2,i,j)=rownj(1:2,i,j)/sumr(1:2)
	   vxwnj(1:2,i,j)=vxwnj(1:2,i,j)/sumu(1:2)
	   vywnj(1:2,i,j)=vywnj(1:2,i,j)/sumv(1:2)
	    pwnj(1:2,i,j)= pwnj(1:2,i,j)/sump(1:2)
     
	 enddo


  enddo

end subroutine weno2d_main


!=============================================
subroutine weno2d_bc
!============================================
  use main

  integer :: il_weno,ir_weno,jl_weno,jr_weno
! complete bc on 4 corner
      ro(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=    ro(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
      vx(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=    vx(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
      vy(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=    vy(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
       p(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=     p(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
!     vmu(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=   vmu(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
!    vmul(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=  vmul(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)
!  alagmx(ib-1:im-ib+1:im,jb-1:jm-jb+1:jm)=alagmx(ib:im-ib-1:im-1,jb:jm-jb-1:jm-1)


! left weno boundary
  il_weno=ib-weno_od+1
  ir_weno=ib-2
  do j=jb-1,jm 
  
  ro(il_weno:ir_weno,j)=    ro(ib-1,j)
  vx(il_weno:ir_weno,j)=    vx(ib-1,j)  
  vy(il_weno:ir_weno,j)=    vy(ib-1,j)  
   p(il_weno:ir_weno,j)=     p(ib-1,j)  
  end do

! right weno boundary
  il_weno=im+1
  ir_weno=im+weno_od-2
  do j=jb-1,jm
  ro(il_weno:ir_weno,j)=    ro(im,j)
  vx(il_weno:ir_weno,j)=    vx(im,j)
  vy(il_weno:ir_weno,j)=    vy(im,j)
   p(il_weno:ir_weno,j)=     p(im,j)
   
  end do

  il_weno=ib-weno_od+1
  ir_weno=im+weno_od-2
  
  jl_weno=jb-weno_od+1   
  jr_weno=jb-2
! bottom weno boundary
  jb_weno=jb+1
  ju_weno=jb+weno_od-2            
  do i=il_weno,ir_weno
    xhalf=0.5*(x(i,jb)+x(i+1,jb))
    if(xhalf>=1./6.) then
    ro(i,jl_weno:jr_weno)=    ro(i,jb-1)   
    vx(i,jl_weno:jr_weno)=    vx(i,jb-1)   
    vy(i,jl_weno:jr_weno)=   -vy(i,jb_weno:ju_weno)   
     p(i,jl_weno:jr_weno)=     p(i,jb-1)
    else
	ro(i,jl_weno:jr_weno)=    ro(i,jb-1)   
    vx(i,jl_weno:jr_weno)=    vx(i,jb-1)   
    vy(i,jl_weno:jr_weno)=    vy(i,jb-1)   
     p(i,jl_weno:jr_weno)=     p(i,jb-1)
    end if 
     
  end do 
  
! up weno boundary  
  jl_weno=jm+1                                              
  jr_weno=jm+weno_od-2                                                      
  do i=il_weno,ir_weno                                                                  
    ro(i,jl_weno:jr_weno)=    ro(i,jm)  
    vx(i,jl_weno:jr_weno)=    vx(i,jm)   
    vy(i,jl_weno:jr_weno)=    vy(i,jm)   
     p(i,jl_weno:jr_weno)=     p(i,jm)   
  end do
end subroutine weno2d_bc